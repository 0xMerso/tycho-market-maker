Merso version
TAP-5: Tycho Market Maker Presentation Speech
Duration: 5-7 minutes | Audience: Expert market makers, arbitrageurs, AMM specialists
===========
OPENING (30 seconds)
Hello everyone. I'm excited to show you TAP-5.
TAP-5 is a price stabilization and market making system. It trades against liquidity pools to maintain prices within defined spreads. Built in Rust. It will be fully open source.
From an arbitrage perspective, TAP-5 is statistical arbitrage, so only with the on-chain leg/side, so single-sided execution.
You can run it for profit, for price stability, or both. Ready for mainnet, Base, and Unichain.
Let me show you what makes it special.
[Transition: First, let's look at the architecture.]
===========
CORE ARCHITECTURE (1 minute)
Three main components work together.
The market maker service monitors pools and executes trades. The monitoring service captures events via Redis and persists to PostgreSQL. The web UI provides real-time visibility.
Data flows from Tycho Streams to our system. We compare pool prices with Binance or Chainlink or any reference price configured.
It swaps when spreads exceed thresholds, with optimal amounts via bundles (for revert protection). Publish results to Redis for real-time updates.
Everything is modular. Price feeds especially. It's the same code, but it has different execution behavior per chain.
[Transition: Now, who can benefit from this?]
===========
QUICK USE CASES (30 seconds)
Let me quickly mention who benefits.
Market makers use this to extend CEX strategies on-chain. Protocol teams deploy it for price stability. Researchers quantify arbitrage opportunities.
Everyone can fork, modify, extend. It's your foundation.
Let me now share my screen to show you the live system.
[ACTION: SHARE SCREEN NOW - https://tap-5.vercel.app/strategies/3ee48b99-9676-4512-a241-f87a77d0b5f7]
[ACTION: Drop link in chat while sharing]
===========
LIVE DEMO - WITH SCREEN SHARED (1.5 minutes)
This is one instance running on Unichain. ETH-USDC pair.
Look at the metrics. 4000 trades in two weeks (we’ve put a low spread threshold, 2 basis points). Net PnL is slightly positive, we’re in progress to compute it precisely but it is quite complex. Fully automated.
Watch the spread chart. See how it maintains the bounds / limits ?
Every trade logged here. Full transparency. Real-time updates through Redis.
The bot considers gas costs. Respects inventory limits. Executes only when profitable after fees.
[Transition: Let me explain the technical details while you're looking at this.]
===========
TECHNICAL DEEP DIVE (2 minutes)
[After demo, while screen is still shared or back to slides]
TYCHO INTEGRATION
We query Tycho API for pool snapshots. Every 500ms by default. Configurable via poll_interval_ms.
Tycho returns current reserves, fees, and pool parameters. We calculate marginal price from this data.
For execution, we use Tycho's router. Smart routing across multiple DEXs.
The simulation engine validates trades before execution. Uses Tycho's state to predict outcomes accurately.
CONFIGURATION VARIABLES IMPACT
Let me explain the key parameters.
Spread Configuration:
• min_watch_spread_bps: Monitoring threshold. Set to 5 means alert at 5 basis points deviation
• min_executable_spread_bps: Execution trigger. Zero means execute immediately when watch threshold hit
• These work together. Watch at 5, execute at 0 creates aggressive strategy
Risk Parameters:
• max_slippage_pct: Transaction revert protection. 0.0005 means 0.05% max price impact
• max_inventory_ratio: Position limits. 0.5 means never allocate more than 50% of the inventory.
• tx_gas_limit: Cap transaction costs. 300000 typical for simple swaps
Performance Tuning:
• poll_interval_ms: API query frequency. Lower means faster reaction, higher API load
• inclusion_block_delay: Wait blocks before trading. Zero for immediate, higher for safety
• skip_simulation: Bypass pre-flight checks. Only for trusted setups with preconf RPCs. For instance on Base with preconf it’s not yet possible to simulate if I’m correct.
CHAIN-SPECIFIC EXECUTION
The execution layer adapts per chain.
Mainnet uses Flashbots bundle API. MEV protection guaranteed and revert protection too. 
Base leverages preconfirmation service. Faster inclusion. Lower latency. Perfect for high-frequency.
Unichain has a custom gas oracle. Different fee structure. Optimized for their consensus.
Each chain module inherits base execution traits. Override specific methods. Clean abstraction.
We can also set a bribe, a percent of the estimated arb profit.
PRICE FEED ARCHITECTURE
Custom feeds plug in easily, just by implementing price feed Rust trait, and configure it in the TOML config. For now, we use Binance and Chainlink.
===========
PRODUCTION READY (30 seconds)
It can handle thousands of pools. Monitoring cost 0 latency due to a Redis pub-sub for real-time events. It uses Docker deployment ready.
Integration tests with real networks. CI/CD pipelines. Battle tested in production.
Transition: So what's coming next?

NEXT STEPS & RESOURCES (30 seconds)
The repositories will be made public soon. Documentation is coming.
Team handles on Telegram and Twitter
We need your feedback so reach out if you want to test or help us improve before public release.
Thank you. I'll hand it back to Tanay now.





















TECHNICAL APPENDIX (For Q&A)

Key Files to Explore:
• src/maker.rs: Entry point with restart logic
• src/shd/maker/impl.rs: Core trading logic
• src/shd/maker/exec/: Chain-specific strategies
• config/*.toml: Example configurations
Performance Metrics:
• Sub-second price updates
• 100ms execution latency
• Handles 1000+ pools simultaneously
• 99.9% uptime with auto-recovery
Security Considerations:
• Private keys in environment variables only
• Simulation before execution
• Slippage protection
• MEV protection on mainnet















